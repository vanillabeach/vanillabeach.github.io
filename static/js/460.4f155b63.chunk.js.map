{"version":3,"file":"static/js/460.4f155b63.chunk.js","mappings":"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","sources":["webpack://2024/./src/components/year/styles.module.css?07eb","components/year/year.tsx","webpack://2024/./src/slides/Synthesia/styles.module.css?12bc","slides/Synthesia/components/videoOverlay.tsx","slides/Synthesia/components/sideBarsOverlay.tsx","slides/Synthesia/index.tsx"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport default {\"date\":\"styles_date__H0UBu\",\"black\":\"styles_black__gJz01\",\"blue\":\"styles_blue__W-SZG\",\"purple\":\"styles_purple__DjlBU\",\"white\":\"styles_white__-41bO\"};","import { memo } from 'react';\nimport classNames from './styles.module.css';\n\nexport interface YearProps {\n  children: React.ReactNode;\n  color?: 'black' | 'white' | 'blue' | 'purple' | undefined;\n}\n\nconst Year = memo(function Year(props: YearProps) {\n  const { children, color } = props;\n  let css = `${classNames.date} `;\n  switch (color) {\n    case 'black':\n      css += `${classNames.black}`;\n      break;\n    case 'blue':\n      css += `${classNames.blue}`;\n      break;\n    case 'purple':\n      css += `${classNames.purple}`;\n      break;\n    case 'white':\n      css += `${classNames.white}`;\n      break;\n    default:\n      css += `${classNames.black}`;\n  }\n\n  return <h1 className={css}>{children}</h1>;\n});\n\nexport default Year;\n","// extracted by mini-css-extract-plugin\nexport default {\"art\":\"styles_art__LIWpi\",\"artContainer\":\"styles_artContainer__hctFi\",\"artPadding\":\"styles_artPadding__apxjo\",\"copyContainer\":\"styles_copyContainer__Vz8tV\",\"static\":\"styles_static__tVnjw\",\"show\":\"styles_show__Lx9PU\",\"sidebars\":\"styles_sidebars__U63JN\",\"container\":\"styles_container__fYMZW\",\"content\":\"styles_content__X4g-Q\",\"copy\":\"styles_copy__BBYmG\"};","import { useRef, useEffect } from \"react\";\nimport * as THREE from 'three';\nimport classNames from '../styles.module.css';\n\nconst MAX_CHUNK_SIZE = 8.0; // Maximum chunk size in pixels\n\ninterface VideoOverlayProps {\n    width: number;\n    height: number;\n}\n\nexport const VideoOverlay = ({ width, height }: VideoOverlayProps) => { \n    const canvasRef = useRef<HTMLCanvasElement>(null);\n\n    useEffect(() => {\n        if (!canvasRef.current) return;\n\n        const canvas = canvasRef.current;\n        \n        // Setup scene\n        const scene = new THREE.Scene();\n        const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n        const renderer = new THREE.WebGLRenderer({ canvas, alpha: true });\n        \n        // TV static shader\n        const staticMaterial = new THREE.ShaderMaterial({\n            uniforms: {\n                time: { value: 0 },\n                chunkSize: { value: 1.0 },\n                resolution: { value: new THREE.Vector2(canvas.clientWidth, canvas.clientHeight) }\n            },\n            vertexShader: `\n                varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                }\n            `,\n            fragmentShader: `\n                uniform float time;\n                uniform float chunkSize;\n                uniform vec2 resolution;\n                varying vec2 vUv;\n                \n                float random(vec2 st) {\n                    return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);\n                }\n                \n                void main() {\n                    vec2 uv = vUv;\n                    \n                    // Pixelate/chunk the UV coordinates based on chunkSize\n                    vec2 pixelSize = chunkSize / resolution;\n                    vec2 chunkedUV = floor(uv / pixelSize) * pixelSize;\n                    \n                    // Generate noise based on chunked position and time\n                    float noise = random(chunkedUV * 100.0 + time * 10.0);\n                    \n                    // Add some scan lines\n                    float scanline = sin(uv.y * 800.0 + time * 5.0) * 0.05;\n                    noise += scanline;\n                    \n                    // Pick random color: blue (#0d58d3) or purple (#ff00ff)\n                    float colorChoice = random(chunkedUV * 50.0 + time * 10.0);\n                    vec3 blue = vec3(0.051, 0.345, 0.827);   // #0d58d3\n                    vec3 purple = vec3(0.0, 1.0, 1.0);        // #08d6ffff\n                    vec3 baseColor = colorChoice > 0.5 ? blue : purple;\n                    \n                    vec3 color = baseColor * noise;\n                    \n                    gl_FragColor = vec4(color, 1.0);\n                }\n            `,\n            transparent: false\n        });\n\n        // Create fullscreen quad\n        const geometry = new THREE.PlaneGeometry(2, 2);\n        const mesh = new THREE.Mesh(geometry, staticMaterial);\n        scene.add(mesh);\n\n        // Set renderer size based on props\n        const updateSize = () => {\n            if (width > 0 && height > 0) {\n                renderer.setSize(width, height, false);\n                staticMaterial.uniforms.resolution.value.set(width, height);\n            }\n        };\n        updateSize();\n\n        // Track distance from viewport and update chunk size\n        const updateChunkSize = () => {\n            const rect = canvas.getBoundingClientRect();\n            const viewportCenter = window.innerHeight / 2;\n            const canvasCenter = rect.top + rect.height / 2;\n            const distanceFromCenter = Math.abs(canvasCenter - viewportCenter);\n            \n            // Map distance to chunk size (1px to 5px)\n            // When in viewport (distance ~0), chunk size is 1px\n            // When far from viewport, chunk size approaches 5px\n            const maxDistance = window.innerHeight;\n            const normalizedDistance = Math.min(distanceFromCenter / maxDistance, 1);\n            const chunkSize = 1 + normalizedDistance * MAX_CHUNK_SIZE; // 1 to 5px\n            \n            staticMaterial.uniforms.chunkSize.value = chunkSize;\n        };\n\n        updateChunkSize();\n        window.addEventListener('scroll', updateChunkSize);\n        window.addEventListener('resize', updateChunkSize);\n\n        // Animation loop\n        let animationId: number;\n        const animate = () => {\n            animationId = requestAnimationFrame(animate);\n            staticMaterial.uniforms.time.value += 0.016; // ~60fps\n            renderer.render(scene, camera);\n        };\n        animate();\n\n        // Cleanup\n        return () => {\n            window.removeEventListener('scroll', updateChunkSize);\n            window.removeEventListener('resize', updateChunkSize);\n            cancelAnimationFrame(animationId);\n            renderer.dispose();\n            geometry.dispose();\n            staticMaterial.dispose();\n        };\n    }, [width, height]);\n\n    return (<canvas className={classNames.static} ref={canvasRef} style={{ width: `${width}px`, height: `${height}px`, display: 'block' }} />)\n}","import { useRef, useEffect, useState } from \"react\";\nimport classNames from '../styles.module.css';\n\ninterface SideBarsOverlayProps {\n    width: number;\n    height: number;\n}\n\nexport const SideBarsOverlay = ({ width, height }: SideBarsOverlayProps) => {\n    const canvasRef = useRef<HTMLCanvasElement>(null);\n    const animationFrameRef = useRef<number>();\n    const [centerFactor, setCenterFactor] = useState(1);\n\n    // Track vertical center position\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n\n        const updateCenterFactor = () => {\n            const rect = canvas.getBoundingClientRect();\n            const canvasCenter = rect.top + rect.height / 2;\n            const viewportCenter = window.innerHeight / 2;\n            \n            // Calculate distance from viewport center (0 = centered, increases as it moves away)\n            const distanceFromCenter = Math.abs(canvasCenter - viewportCenter);\n            const maxDistance = window.innerHeight / 2 + rect.height / 2;\n            \n            // Convert to a 0-1 factor where 0 = perfectly centered, 1 = at edge/off screen\n            const normalizedDistance = Math.min(distanceFromCenter / maxDistance, 1);\n            \n            setCenterFactor(normalizedDistance);\n        };\n\n        updateCenterFactor();\n        window.addEventListener('scroll', updateCenterFactor);\n        window.addEventListener('resize', updateCenterFactor);\n\n        return () => {\n            window.removeEventListener('scroll', updateCenterFactor);\n            window.removeEventListener('resize', updateCenterFactor);\n        };\n    }, []);\n\n    useEffect(() => {\n        const canvas = canvasRef.current;\n        if (!canvas) return;\n\n        const ctx = canvas.getContext('2d');\n        if (!ctx) return;\n\n        // Set canvas resolution\n        const dpr = window.devicePixelRatio || 1;\n        canvas.width = width * dpr;\n        canvas.height = height * dpr;\n        ctx.scale(dpr, dpr);\n\n        // Animation state\n        let time = 0;\n        const maxRippleWidth = width * 0.25; // Up to 25% of canvas width\n\n        // Create multiple ripple bands for more variation\n        const leftRipples = Array.from({ length: 5 }, (_, i) => ({\n            speed: 0.02 + Math.random() * 0.03,\n            offset: Math.random() * Math.PI * 2,\n            frequency: 1 + Math.random() * 2\n        }));\n\n        const rightRipples = Array.from({ length: 5 }, (_, i) => ({\n            speed: 0.02 + Math.random() * 0.03,\n            offset: Math.random() * Math.PI * 2,\n            frequency: 1 + Math.random() * 2\n        }));\n\n        const animate = () => {\n            // Clear canvas\n            ctx.clearRect(0, 0, width, height);\n\n            time += 0.016; // ~60fps\n\n            // Draw left side ripples\n            leftRipples.forEach((ripple, index) => {\n                const waveValue = Math.sin(time * ripple.speed * ripple.frequency + ripple.offset);\n                // Create sharp transitions by using step function\n                const sharpValue = waveValue > 0 ? 1 : 0;\n                const rippleWidth = sharpValue * maxRippleWidth * (0.3 + Math.random() * 0.7) * centerFactor;\n\n                if (rippleWidth > 0) {\n                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n                    ctx.fillRect(0, 0, rippleWidth, height);\n                }\n            });\n\n            // Draw right side ripples\n            rightRipples.forEach((ripple, index) => {\n                const waveValue = Math.sin(time * ripple.speed * ripple.frequency + ripple.offset);\n                // Create sharp transitions by using step function\n                const sharpValue = waveValue > 0 ? 1 : 0;\n                const rippleWidth = sharpValue * maxRippleWidth * (0.3 + Math.random() * 0.7) * centerFactor;\n\n                if (rippleWidth > 0) {\n                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';\n                    ctx.fillRect(width - rippleWidth, 0, rippleWidth, height);\n                }\n            });\n\n            animationFrameRef.current = requestAnimationFrame(animate);\n        };\n\n        animate();\n\n        return () => {\n            if (animationFrameRef.current) {\n                cancelAnimationFrame(animationFrameRef.current);\n            }\n        };\n    }, [width, height, centerFactor]);\n\n    return (<canvas className={classNames.sidebars} ref={canvasRef} style={{ width: `${width}px`, height: `${height}px`, display: 'block' }} />)\n}","import { useEffect, useRef, useState } from 'react';\nimport { isWithinViewport } from '../../utils';\nimport classNames from './styles.module.css';\nimport Year from '../../components/year/year';\nimport stockVideo from './videos/s2.mp4';\nimport { VideoOverlay } from './components/videoOverlay';\nimport debounce from 'debounce';\nimport { config } from '../../data/config';\nimport { SideBarsOverlay } from './components/sideBarsOverlay';\n\nexport default function Synthesia() {\n  const containerRef = useRef<HTMLDivElement>(null);\n  const canvasContainerRef = useRef<HTMLDivElement>(null);\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const [showFullContent, setShowFullContent] = useState<boolean>(\n    window.innerWidth > config.mobileWaxWidth,\n  );\n  const [visibility, setVisibility] = useState<number>(0);\n  const [aspect, setAspect] = useState<number>(16 / 9);\n  const [mediaSize, setMediaSize] = useState<{ width: number; height: number }>({\n    width: 0,\n    height: 0,\n  });\n  const [videoOpacity, setVideoOpacity] = useState<number>(1);\n  const [videoBlur, setVideoBlur] = useState<number>(0);\n\n  useEffect(() => {\n    const handleWidth = debounce(() => {\n      setShowFullContent(window.innerWidth > config.mobileWaxWidth);\n    }, 10);\n\n    window.addEventListener('resize', handleWidth);\n\n    return () => {\n      window.removeEventListener('resize', handleWidth);\n    };\n  }, [showFullContent]);\n\n  useEffect(() => {\n    const v = videoRef.current;\n    if (!v) return;\n    v.muted = true;\n    const onLoadedMeta = () => {\n      if (v.videoWidth && v.videoHeight) {\n        setAspect(v.videoWidth / v.videoHeight);\n      }\n    };\n    v.addEventListener('loadedmetadata', onLoadedMeta);\n    const p = v.play();\n    if (p && typeof (p as Promise<void>).catch === 'function') {\n      (p as Promise<void>).catch(() => void 0);\n    }\n\n    return () => {\n      v.removeEventListener('loadedmetadata', onLoadedMeta);\n    };\n  }, []);\n\n  // Compute media size: fill entire container\n  useEffect(() => {\n    const el = canvasContainerRef.current;\n    if (!el) return;\n\n    const compute = () => {\n      const rect = el.getBoundingClientRect();\n      const w = Math.max(0, rect.width);\n      const h = Math.max(0, rect.height);\n      setMediaSize({ width: Math.round(w), height: Math.round(h) });\n    };\n\n    const doCompute = debounce(compute, 10);\n    compute();\n    window.addEventListener('resize', doCompute);\n\n    return () => {\n      window.removeEventListener('resize', doCompute);\n    };\n  }, [canvasContainerRef.current]);\n\n  useEffect(() => {\n    const el = canvasContainerRef.current;\n    const v = videoRef.current;\n    if (!el || !v) return;\n\n    let observer: IntersectionObserver | null = null;\n    if ('IntersectionObserver' in globalThis) {\n      observer = new IntersectionObserver(\n        (entries) => {\n          entries.forEach((entry) => {\n            const visible = entry.isIntersecting && entry.intersectionRatio > 0.2;\n            setVisibility(entry.intersectionRatio);\n            if (visible) {\n              v.play().catch(() => void 0);\n            } else {\n              try {\n                v.pause();\n              } catch (e) {\n                void e;\n              }\n            }\n          });\n        },\n        { threshold: [0, 0.2, 0.5, 1] },\n      );\n\n      observer.observe(el);\n    } else {\n      const onCheck = () => {\n        if (isWithinViewport(el)) {\n          v.play().catch(() => void 0);\n          setVisibility(1);\n        } else {\n          try {\n            v.pause();\n          } catch (e) {\n            void e;\n          }\n          setVisibility(0);\n        }\n      };\n\n      globalThis.addEventListener('scroll', onCheck, { passive: true });\n      globalThis.addEventListener('resize', onCheck);\n      // initial check\n      onCheck();\n\n      return () => {\n        globalThis.removeEventListener('scroll', onCheck);\n        globalThis.removeEventListener('resize', onCheck);\n      };\n    }\n\n    return () => {\n      if (observer) observer.disconnect();\n    };\n  }, []);\n\n  // Track vertical distance from viewport center for video opacity\n  useEffect(() => {\n    const el = canvasContainerRef.current;\n    if (!el) return;\n\n    const updateOpacity = () => {\n      const rect = el.getBoundingClientRect();\n      const elementCenter = rect.top + rect.height / 2;\n      const viewportCenter = window.innerHeight / 2;\n\n      const distanceFromCenter = Math.abs(elementCenter - viewportCenter);\n      const maxDistance = window.innerHeight / 2 + rect.height / 2;\n\n      // 1 = centered (full opacity), 0 = at edge (no opacity)\n      const opacity = 1 - Math.min(distanceFromCenter / maxDistance, 1);\n      setVideoOpacity(opacity - 0.0001);\n\n      // 0 = centered (no blur), up to 5px = at edge (max blur)\n      const blurDistance = Math.min(distanceFromCenter / maxDistance, 1);\n      const blur = blurDistance * 5; // 0 to 5px\n      setVideoBlur(blur);\n    };\n\n    updateOpacity();\n    window.addEventListener('scroll', updateOpacity, { passive: true });\n    window.addEventListener('resize', updateOpacity);\n\n    return () => {\n      window.removeEventListener('scroll', updateOpacity);\n      window.removeEventListener('resize', updateOpacity);\n    };\n  }, []);\n\n  return (\n    <div className={classNames.container} ref={containerRef}>\n      <div className={classNames.content}>\n        <section className={classNames.copyContainer}>\n          <div className={classNames.copy}>\n            <Year color=\"purple\">2024</Year>\n            <h1 className=\"text-4xl font-medium mb-3\">SYNTHESIA</h1>\n            <p className=\"mb-3\">\n              Synthesia is the #1 AI Video Communications Platform. The use ultra-sophisticated\n              voice and video generation within a modern web app that enables everyone to create\n              professional videos without mics, cameras, actors or studios.\n            </p>\n            <p>\n              I joined as a Senior Frontend Engineer in 2024, working on the UI for Avatars &amp;\n              Voice editing, as well as integrating B-Roll AI videos and images, and enabling users\n              to create ultra-realistic, branded avatars using professional avatars or event\n              themselves.\n            </p>\n          </div>\n        </section>\n        <section className={classNames.art} style={{ display: showFullContent ? 'flex' : 'none' }}>\n          <div className={classNames.artPadding}>\n            <div className={classNames.artContainer} ref={canvasContainerRef}>\n              <SideBarsOverlay width={mediaSize.width} height={mediaSize.height} />\n              <VideoOverlay width={mediaSize.width} height={mediaSize.height} />\n              <video\n                ref={videoRef}\n                autoPlay\n                muted\n                src={stockVideo}\n                playsInline\n                style={{\n                  width: '100%',\n                  height: '100%',\n                  objectFit: 'cover',\n                  display: 'block',\n                  opacity: videoOpacity,\n                  filter: `blur(${videoBlur}px)`,\n                }}\n                preload=\"auto\"\n                loop\n              />\n            </div>\n          </div>\n        </section>\n      </div>\n    </div>\n  );\n}\n"],"names":["memo","props","children","color","css","concat","classNames","_jsx","className","VideoOverlay","_ref","width","height","canvasRef","useRef","useEffect","current","canvas","scene","THREE","camera","renderer","alpha","staticMaterial","uniforms","time","value","chunkSize","resolution","clientWidth","clientHeight","vertexShader","fragmentShader","transparent","geometry","mesh","add","setSize","set","updateChunkSize","rect","getBoundingClientRect","viewportCenter","window","innerHeight","canvasCenter","top","distanceFromCenter","Math","abs","maxDistance","min","animationId","addEventListener","animate","requestAnimationFrame","render","removeEventListener","cancelAnimationFrame","dispose","static","ref","style","display","SideBarsOverlay","animationFrameRef","centerFactor","setCenterFactor","useState","updateCenterFactor","normalizedDistance","ctx","getContext","dpr","devicePixelRatio","scale","maxRippleWidth","leftRipples","Array","from","length","_","i","speed","random","offset","PI","frequency","rightRipples","clearRect","forEach","ripple","index","rippleWidth","sin","fillStyle","fillRect","sidebars","Synthesia","containerRef","canvasContainerRef","videoRef","showFullContent","setShowFullContent","innerWidth","config","mobileWaxWidth","visibility","setVisibility","aspect","setAspect","mediaSize","setMediaSize","videoOpacity","setVideoOpacity","videoBlur","setVideoBlur","handleWidth","debounce","v","muted","onLoadedMeta","videoWidth","videoHeight","p","play","catch","el","compute","w","max","h","round","doCompute","observer","globalThis","onCheck","isWithinViewport","pause","e","passive","IntersectionObserver","entries","entry","visible","isIntersecting","intersectionRatio","threshold","observe","disconnect","updateOpacity","elementCenter","opacity","blurDistance","container","_jsxs","content","copyContainer","copy","Year","art","artPadding","artContainer","autoPlay","src","stockVideo","playsInline","objectFit","filter","preload","loop"],"sourceRoot":""}